// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3824.Competition2018.subsystems;

import org.usfirst.frc3824.Competition2018.Constants;
import org.usfirst.frc3824.Competition2018.Robot;
import org.usfirst.frc3824.Competition2018.RobotMap;
import org.usfirst.frc3824.Competition2018.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.ParamEnum;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/*********************************************************************
 *
 *********************************************************************/
public class Intake extends Subsystem
{

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX right = RobotMap.intakeRight;
    private final WPI_TalonSRX left = RobotMap.intakeLeft;
    private final WPI_TalonSRX angle = RobotMap.intakeAngle;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private double intakeAnglePIDParamF = Constants.IntakeAnglePIDParamF;
    private double intakeAnglePIDParamP = Constants.IntakeAnglePIDParamP;
    private double intakeAnglePIDParamI = Constants.IntakeAnglePIDParamI;
    private double intakeAnglePIDParamD = Constants.IntakeAnglePIDParamD;
    private int intakeAngleCruiseVelocity = Constants.IntakeAngleCruiseVelocity;
    private int intakeAngleAcceleration = Constants.IntakeAngleAcceleration;
    
    private double intakeAngleSetpoint  = 0;
    
    private double intakeWheelPIDParamF = Constants.IntakeWheelPIDParamF;
    private double intakeWheelPIDParamP = Constants.IntakeWheelPIDParamP;
    private double intakeWheelPIDParamI = Constants.IntakeWheelPIDParamI;
    private double intakeWheelPIDParamD = Constants.IntakeWheelPIDParamD;
    
    private double intakeWheelLeftSetpoint  = 0;
    private double intakeWheelRightSetpoint  = 0;

    /*********************************************************************
     *
     *********************************************************************/
    public Intake()
    {
        /**********************************************************************************/
        left.set(ControlMode.Velocity, 0);
        left.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, Constants.TalonInitialCommunicationTimeout);
        left.setSensorPhase(false);

        left.configClosedloopRamp(0, Constants.TalonInitialCommunicationTimeout);

        left.configNominalOutputForward(0, Constants.TalonInitialCommunicationTimeout);
        left.configNominalOutputReverse(0, Constants.TalonInitialCommunicationTimeout);
        left.configPeakOutputForward(Constants.IntakeWheelPIDMaximum, Constants.TalonInitialCommunicationTimeout);
        left.configPeakOutputReverse(Constants.IntakeWheelPIDMinimum, Constants.TalonInitialCommunicationTimeout);

        left.config_kF(0, intakeWheelPIDParamF, Constants.TalonInitialCommunicationTimeout);
        left.config_kP(0, intakeWheelPIDParamP, Constants.TalonInitialCommunicationTimeout);
        left.config_kI(0, intakeWheelPIDParamI, Constants.TalonInitialCommunicationTimeout);
        left.config_kD(0, intakeWheelPIDParamD, Constants.TalonInitialCommunicationTimeout);

        resetLeftWheelPosition();

        /**********************************************************************************/
        right.set(ControlMode.Velocity, 0);
        right.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, Constants.TalonInitialCommunicationTimeout);
        right.setInverted(true);

        right.configClosedloopRamp(0, Constants.TalonInitialCommunicationTimeout);

        right.configNominalOutputForward(0, Constants.TalonInitialCommunicationTimeout);
        right.configNominalOutputReverse(0, Constants.TalonInitialCommunicationTimeout);
        right.configPeakOutputForward(Constants.IntakeWheelPIDMaximum, Constants.TalonInitialCommunicationTimeout);
        right.configPeakOutputReverse(Constants.IntakeWheelPIDMinimum, Constants.TalonInitialCommunicationTimeout);

        right.config_kF(0, intakeWheelPIDParamF, Constants.TalonInitialCommunicationTimeout);
        right.config_kP(0, intakeWheelPIDParamP, Constants.TalonInitialCommunicationTimeout);
        right.config_kI(0, intakeWheelPIDParamI, Constants.TalonInitialCommunicationTimeout);
        right.config_kD(0, intakeWheelPIDParamD, Constants.TalonInitialCommunicationTimeout);

        resetRightWheelPosition();

        /**********************************************************************************/
        resetAnglePosition();
        
        angle.set(ControlMode.MotionMagic, 0);
        angle.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, Constants.TalonInitialCommunicationTimeout);
        angle.setSensorPhase(false);
              
        angle.configNominalOutputForward(0, Constants.TalonInitialCommunicationTimeout);
        angle.configNominalOutputReverse(0, Constants.TalonInitialCommunicationTimeout);
        angle.configPeakOutputForward(Constants.IntakeAnglePIDMaximum, Constants.TalonInitialCommunicationTimeout);
        angle.configPeakOutputReverse(Constants.IntakeAnglePIDMinimum, Constants.TalonInitialCommunicationTimeout);
        
        angle.config_kF(0, intakeAnglePIDParamF, Constants.TalonInitialCommunicationTimeout);
        angle.config_kP(0, intakeAnglePIDParamP, Constants.TalonInitialCommunicationTimeout);
        angle.config_kI(0, intakeAnglePIDParamI, Constants.TalonInitialCommunicationTimeout);
        angle.config_kD(0, intakeAnglePIDParamD, Constants.TalonInitialCommunicationTimeout);
        
        angle.configMotionCruiseVelocity(Constants.IntakeAngleCruiseVelocity, Constants.TalonInitialCommunicationTimeout);
        angle.configMotionAcceleration(Constants.IntakeAngleAcceleration, Constants.TalonInitialCommunicationTimeout);
        
        // Ensure the intake wheels are not moving
        stopIntake();
        
        System.out.println("*** Intake Constructor ***");
    }

    /*********************************************************************
     * Returns error of PID algorithm for the right intake controller
     *********************************************************************/
    public double getPID_ErrorRight()
    {
        return right.getClosedLoopError(0);
    }

    /*********************************************************************
     * Returns output of right intake motor in volts
     *********************************************************************/
    public double getMotorVoltageRight()
    {
        return right.getMotorOutputVoltage();
    }

    /*********************************************************************
     * Returns percent of maximum output of right intake motor
     *********************************************************************/
    public double getMotorPercentRight()
    {
        return right.getMotorOutputPercent();
    }

    /*********************************************************************
     * Returns current control mode for Talon SRXs for intake right motors
     *********************************************************************/
    public ControlMode getMotorControlModeRight()
    {
        return right.getControlMode();
    }

    /*********************************************************************
     * Returns current setpoint being targeted for the right intake motors
     *********************************************************************/
    public double getPID_SetpointRight()
    {
        return intakeWheelRightSetpoint;
    }

    /*********************************************************************
     * Returns current velocity of right intake motor calculated by controller
     *********************************************************************/
    public double getVelocityRight()
    {
        return right.getSelectedSensorVelocity(0);
    }

    /*********************************************************************
     *  Returns current encoder position of right intake controller
     *********************************************************************/
    public double getPositionRight()
    {
        return right.getSelectedSensorPosition(0);
    }

    /*********************************************************************
    * Resets right intake sensor encoder value to 0
    *********************************************************************/
    public void resetRightWheelPosition()
    {
        right.setSelectedSensorPosition(0, 0, Constants.TalonInitialCommunicationTimeout);
    }

    /*********************************************************************
     * Returns error of PID algorithm for the left intake controller
     *********************************************************************/
    public double getPID_ErrorLeft()
    {
        return left.getClosedLoopError(0);
    }

    /*********************************************************************
     * Returns output of left intake motor in volts
     *********************************************************************/
    public double getMotorVoltageLeft()
    {
        return left.getMotorOutputVoltage();
    }

    /*********************************************************************
     * Returns percent of maximum output of left intake motor
     *********************************************************************/
    public double getMotorPercentLeft()
    {
        return left.getMotorOutputPercent();
    }

    /*********************************************************************
     * Returns current control mode for Talon SRXs for intake left motors
     *********************************************************************/
    public ControlMode getMotorControlModeLeft()
    {
        return left.getControlMode();
    }

    /*********************************************************************
     * Returns current setpoint being targeted for the left intake motors
     *********************************************************************/
    public double getPID_SetpointLeft()
    {
        return intakeWheelLeftSetpoint;
    }

    /*********************************************************************
     * Returns current velocity of right intake motor calculated by controller
     *********************************************************************/
    public double getVelocityLeft()
    {
        return left.getSelectedSensorVelocity(0);
    }

    /*********************************************************************
     * Returns current encoder position of left intake controller
     *********************************************************************/
    public double getPositionLeft()
    {
        return left.getSelectedSensorPosition(0);
    }

    /*********************************************************************
    * Resets left intake sensor encoder value to 0
    *********************************************************************/
    public void resetLeftWheelPosition()
    {
        left.setSelectedSensorPosition(0, 0, Constants.TalonInitialCommunicationTimeout);
    }

    /*********************************************************************
     * Returns error of PID algorithm for the intake angle controller
     *********************************************************************/
    public double getPID_ErrorAngle()
    {
        return angle.getClosedLoopError(0);
    }

    /*********************************************************************
     * Returns output of intake angle motor in volts
     *********************************************************************/
    public double getMotorVoltageAngle()
    {
        return angle.getMotorOutputVoltage();
    }

    /*********************************************************************
     * Returns percent of maximum output of intake angle motor
     *********************************************************************/
    public double getMotorPercentAngle()
    {
        return angle.getMotorOutputPercent();
    }

    /*********************************************************************
     * Returns current control mode for Talon SRXs for intake angle
     *********************************************************************/
    public ControlMode getMotorControlModeAngle()
    {
        return angle.getControlMode();
    }

    /*********************************************************************
     * Returns current setpoint being targeted for the intake angle
     *********************************************************************/
    public double getPID_SetpointAngle()
    {
        return intakeAngleSetpoint;
    }

    /*********************************************************************
     * Returns current angle of intake as an encoder value
     *********************************************************************/
    public double getPositionAngle()
    {
        return angle.getSelectedSensorPosition(0);
    }
    
    /*********************************************************************
     * Returns current velocity of angle of intake as an encoder value
     *********************************************************************/
    public double getVelocityAngle()
    {
        return angle.getSelectedSensorVelocity(0);
    }

    /*********************************************************************
    * Resets angle sensor encoder value to 0
    *********************************************************************/
    public void resetAnglePosition()
    {
        angle.setSelectedSensorPosition(0, 0, Constants.TalonInitialCommunicationTimeout);
    }
    
    /*********************************************************************
     *  
     *********************************************************************/
    @Override
    public void initDefaultCommand()
    {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new IntakeTeleop());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.1
        // setDefaultCommand(new MySpecialCommand());
    }

    /*********************************************************************
     * Method that runs in a periodic loop that constantly sets the angle of the intake based on user input
     *********************************************************************/
    @Override
    public void periodic()
    {
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    /*********************************************************************
    * Sets the RPM of the intake wheels to 0 (stops the motors)
    *********************************************************************/
    public void stopIntake()
    {
        // speed for spitting out cube
        left.set(0);
        right.set(0);
    }

    /*********************************************************************
     *
     *********************************************************************/
    public boolean shouldStop()
    {
        // TODO: add code to turn off wheels when cube is fully inside
        return false;
    }

    /*********************************************************************
     * Uses PIDs with Talon SRX encoder feedback to set the RPM of the intake wheels to a specified velocity
     *********************************************************************/
    public void setRPM(boolean direction, double RPM)
    {
        /* Speed mode */
        /*
         * 4096 Units/Rev * 500 RPM / 600 100ms/min in either direction:
         * velocity setpoint is in units/100ms 500 RPM is maximum wheel speed
         */
        double targetVelocity = RPM * 4096 / 600;

        // Determine the wheel direction
        if (direction == true)
            targetVelocity = -targetVelocity;

        // Set the wheel PID velocity setpoint
        left.set(ControlMode.Velocity, targetVelocity);
        right.set(ControlMode.Velocity, targetVelocity);
        
        intakeWheelLeftSetpoint  = targetVelocity;
        intakeWheelRightSetpoint = targetVelocity;

//        SmartDashboard.putNumber("Intake Target Velocity", targetVelocity);
//        SmartDashboard.putNumber("Intake RPM",RPM);
    }
    
    /*********************************************************************
     * Uses PIDs with Talon SRX encoder feedback to set the RPM of the 
     * right intake wheels to a specified velocity
     *********************************************************************/
    public void setRPMRight(boolean direction, double RPM)
    {
        /* Speed mode */
        /*
         * 4096 Units/Rev * 500 RPM / 600 100ms/min in either direction:
         * velocity setpoint is in units/100ms 500 RPM is maximum wheel speed
         */
        double targetVelocity = RPM * 4096 / 600;

        // Determine the wheel direction
        if (direction == true)
            targetVelocity = -targetVelocity;

        // Set the wheel PID velocity setpoint
        right.set(ControlMode.Velocity, targetVelocity);
        
        intakeWheelRightSetpoint = targetVelocity;
    }
    
    /*********************************************************************
     * Uses PIDs with Talon SRX encoder feedback to set the RPM of the 
     * left intake wheels to a specified velocity
     *********************************************************************/
    public void setRPMLeft(boolean direction, double RPM)
    {
        /* Speed mode */
        /*
         * 4096 Units/Rev * 500 RPM / 600 100ms/min in either direction:
         * velocity setpoint is in units/100ms 500 RPM is maximum wheel speed
         */
        double targetVelocity = RPM * 4096 / 600;

        // Determine the wheel direction
        if (direction == true)
            targetVelocity = -targetVelocity;

        // Set the wheel PID velocity setpoint
        left.set(ControlMode.Velocity, targetVelocity);
        
        intakeWheelLeftSetpoint = targetVelocity;
    }
    
    /*********************************************************************
     * Sets voltage percent to intake wheels
     *********************************************************************/
    public void setWheelVoltage(boolean direction, double power)
    {  
        // Determine the wheel direction
        if (direction == true)
            power = -power;

        // Set the wheel PID velocity setpoint
        left.set(ControlMode.PercentOutput, power);
        right.set(ControlMode.PercentOutput, power);
    }

    /*********************************************************************
     * Uses PIDs with Talon SRX encoder feedback to set the position of the intake to a specified angle
     *********************************************************************/
    public void setAngle(double positionAngle)
    {
        if (positionAngle < Constants.IntakeMinimumAngle)
        {
            positionAngle = Constants.IntakeMinimumAngle;
        } 
        else if (positionAngle > Constants.IntakeMaximumAngle)
        {
            positionAngle = Constants.IntakeMaximumAngle;
        }

        double calculatedAngle = (positionAngle * (Constants.IntakeAngleEncoderYIntercept / 90)) + Constants.IntakeAngleEncoderYIntercept;  
        angle.set(ControlMode.MotionMagic, calculatedAngle);
        
        intakeAngleSetpoint = calculatedAngle;
        
//        SmartDashboard.putNumber("Calculated Angle", calculatedAngle);
    }
    
    /*********************************************************************
     *
     *********************************************************************/
    public void setAnglePosition(double position)
    {
        angle.set(ControlMode.MotionMagic, position);
        
        intakeAngleSetpoint = position;
    }
    
    /*********************************************************************
     *
     *********************************************************************/
    public void setIntakeRotatePID()
    {
        intakeAnglePIDParamF      = SmartDashboard.getNumber("F", Constants.IntakeAnglePIDParamF);
        intakeAnglePIDParamP      = SmartDashboard.getNumber("P", Constants.IntakeAnglePIDParamP);
        intakeAnglePIDParamI      = SmartDashboard.getNumber("I", Constants.IntakeAnglePIDParamI);
        intakeAnglePIDParamD      = SmartDashboard.getNumber("D", Constants.IntakeAnglePIDParamD);
        intakeAngleCruiseVelocity = (int)SmartDashboard.getNumber("Velocity", Constants.IntakeAngleCruiseVelocity);
        intakeAngleAcceleration   = (int)SmartDashboard.getNumber("Acceleration", Constants.IntakeAngleAcceleration);
        
        angle.config_kF(0, intakeAnglePIDParamF, Constants.TalonInitialCommunicationTimeout);
        angle.config_kP(0, intakeAnglePIDParamP, Constants.TalonInitialCommunicationTimeout);
        angle.config_kI(0, intakeAnglePIDParamI, Constants.TalonInitialCommunicationTimeout);
        angle.config_kD(0, intakeAnglePIDParamD, Constants.TalonInitialCommunicationTimeout);
        
        angle.configMotionCruiseVelocity(intakeAngleCruiseVelocity, Constants.TalonInitialCommunicationTimeout);
        angle.configMotionAcceleration(intakeAngleAcceleration, Constants.TalonInitialCommunicationTimeout);
    }
    
    /*********************************************************************
     *
     *********************************************************************/
    public void setIntakeWheelPID()
    {
        intakeWheelPIDParamF = SmartDashboard.getNumber("F", Constants.IntakeWheelPIDParamF);
        intakeWheelPIDParamP = SmartDashboard.getNumber("P", Constants.IntakeWheelPIDParamP);
        intakeWheelPIDParamI = SmartDashboard.getNumber("I", Constants.IntakeWheelPIDParamI);
        intakeWheelPIDParamD = SmartDashboard.getNumber("D", Constants.IntakeWheelPIDParamD);
        
        left.config_kF(0, intakeWheelPIDParamF, Constants.TalonInitialCommunicationTimeout);
        left.config_kP(0, intakeWheelPIDParamP, Constants.TalonInitialCommunicationTimeout);
        left.config_kI(0, intakeWheelPIDParamI, Constants.TalonInitialCommunicationTimeout);
        left.config_kD(0, intakeWheelPIDParamD, Constants.TalonInitialCommunicationTimeout);
        
        right.config_kF(0, intakeWheelPIDParamF, Constants.TalonInitialCommunicationTimeout);
        right.config_kP(0, intakeWheelPIDParamP, Constants.TalonInitialCommunicationTimeout);
        right.config_kI(0, intakeWheelPIDParamI, Constants.TalonInitialCommunicationTimeout);
        right.config_kD(0, intakeWheelPIDParamD, Constants.TalonInitialCommunicationTimeout);
    }
}
